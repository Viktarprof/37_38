// Реализовать алгоритм QuickSort, когда в качестве опорного элемента (pivot) мы выбираем не последний элемент в массиве, а случайный.

// ЗадачкаДан массив строк. Нужно найти самый длинный общий префикс, используя парадигму DivideAndConquer.


// Пример, 
// arr = ["return","retard","reunion","rest"]
// prefix = "re"


// arr = ["cheer", "cheerful", "cheese"]
// prefix = "chee"


// arr = ["mirror", "nothing"]
// prefix = "" 

// QuickSort с выбором случайного опорного элемента в массиве можно реализовать следующим образом:

// Выбираем случайный индекс из диапазона [low, high], где low - индекс первого элемента массива, а high - индекс последнего элемента массива.
// Обменяем элемент с выбранным индексом с последним элементом в массиве (таким образом, опорный элемент теперь находится в конце массива).
// Проходим по массиву от low до high-1 и, если элемент меньше или равен опорному, меняем его с элементом, находящимся в текущей позиции левее опорного элемента.
// Обменяем опорный элемент со следующим элементом после последнего меньшего или равного ему (этот элемент станет разделителем между элементами, меньшими и большими опорного).
// Рекурсивно вызываем QuickSort для левой части массива (от low до pivot-1) и правой части массива (от pivot+1 до high).

function quicksort(arr, low = 0, high = arr.length - 1) {
  if (low < high) {
    // выбираем случайный опорный элемент
    const pivotIndex = Math.floor(Math.random() * (high - low + 1) + low);
    // перемещаем опорный элемент в конец массива
    [arr[pivotIndex], arr[high]] = [arr[high], arr[pivotIndex]];
    // разбиваем массив на две части
    let i = low - 1;
    for (let j = low; j < high; j++) {
      if (arr[j] <= arr[high]) {
        i++;
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }
    // перемещаем опорный элемент в правильную позицию
    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
    const pivot = i + 1;
    // вызываем quicksort для левой и правой части массива
    quicksort(arr, low, pivot - 1);
    quicksort(arr, pivot + 1, high);
  }
  return arr;
}


// Эта функция принимает массив arr, а также необязательные аргументы low и high, 
// которые определяют границы сортировки в массиве (по умолчанию сортируется весь массив).
//  Внутри функции происходит выбор случайного опорного элемента, разбиение массива на две части, 
//  перемещение опорного элемента 
// в правильную позицию и рекурсивный вызов quicksort для левой и правой части массива. 
// Функция возвращает отсортированный массив.