// Даны два целых числа x и n, напишите функцию для вычисления x^n
// решение 1 - рекурсивно O(n)
// решение 2 - улучшить решение 1 до O(lon n)

function power(x, n) {
  if (n === 0) {
    return 1;
  } else if (n < 0) {
    return 1 / power(x, -n);
  } else {
    return x * power(x, n - 1);
  }
}


// Эта функция вычисляет x^n рекурсивно. Если n равно 0, она возвращает 1. Если n отрицательное, 
// она вычисляет 1/x^-n. В остальных случаях она возвращает x * x^(n-1).

// Решение 2 - улучшить решение 1 до O(lon n):
function power(x, n) {
  if (n === 0) {
    return 1;
  } else if (n < 0) {
    return 1 / power(x, -n);
  } else if (n % 2 === 0) {
    const y = power(x, n / 2);
    return y * y;
  } else {
    return x * power(x, n - 1);
  }
}


// Эта функция также вычисляет x^n, но использует более оптимальный подход для 
// уменьшения количества операций умножения. Она проверяет, является ли n четным числом.
//  Если это так, она вычисляет x^(n/2) только один раз и возвращает его квадрат. 
//  Если n нечетное, она вычисляет x * x^(n-1), где x^(n-1) вычисляется рекурсивно. 
// Таким образом, количество операций умножения снижается с O(n) до O(log n).







// Имея два отсортированных массива размера m и n соответственно, вам нужно найти элемент, 
// который будет находиться на k-й позиции в конечном отсортированном массиве.
// Массив 1 - 100 112 256 349 770
// Массив 2 - 72 86 113 119 265 445 892
// к = 7
// Вывод : 256
// Окончательный отсортированный массив -
// 72, 86, 100, 112, 113, 119, 256, 265, 349, 445, 770, 892
// 7-й элемент этого массива равен 256.

// Для решения этой задачи можно использовать метод слияния (merge). 
// Для этого нужно создать третий массив и последовательно добавлять 
// элементы из двух исходных массивов,
//  сохраняя их порядок. Затем мы можем найти элемент на k-й позиции в этом массиве.

function findKthElement(arr1, arr2, k) {
  const merged = [];
  let i = 0, j = 0;

  // Слияние двух отсортированных массивов
  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] < arr2[j]) {
      merged.push(arr1[i]);
      i++;
    } else {
      merged.push(arr2[j]);
      j++;
    }
  }
  // Добавление оставшихся элементов
  while (i < arr1.length) {
    merged.push(arr1[i]);
    i++;
  }
  while (j < arr2.length) {
    merged.push(arr2[j]);
    j++;
  }

  // Нахождение k-го элемента
  return merged[k - 1];
}

const arr1 = [100, 112, 256, 349, 770];
const arr2 = [72, 86, 113, 119, 265, 445, 892];
const k = 7;

const result = findKthElement(arr1, arr2, k);
console.log(result); // 256


// Этот код сначала создает новый массив merged и объединяет два исходных массива в один, сохраняя порядок. 
// Затем он возвращает k-й элемент этого объединенного массива, который равен 256 для данного примера.



// Имея отсортированный массив arr[] и число x, напишите функцию, которая подсчитывает вхождения x в arr[]. Ожидаемая временная сложность O(Log n)
// arr[] = {1, 1, 2, 2, 2, 2, 3,} 
// x = 2
// Вывод: 4 раза


// Для решения этой задачи можно использовать модифицированный бинарный поиск. Мы можем найти первое и последнее вхождение элемента x в массив, а затем вычислить количество вхождений, как разницу между этими индексами, плюс 1. Это займет O(log n) времени, так как мы используем бинарный поиск для нахождения двух индексов.

function countOccurrences(arr, x) {
  const n = arr.length;
  let first = -1, last = -1;

  // Нахождение первого вхождения
  let low = 0, high = n - 1;
  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    if (arr[mid] < x) {
      low = mid + 1;
    } else if (arr[mid] > x) {
      high = mid - 1;
    } else {
      first = mid;
      high = mid - 1;
    }
  }

  // Нахождение последнего вхождения
  low = 0, high = n - 1;
  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    if (arr[mid] < x) {
      low = mid + 1;
    } else if (arr[mid] > x) {
      high = mid - 1;
    } else {
      last = mid;
      low = mid + 1;
    }
  }

  // Вычисление количества вхождений
  if (first == -1 || last == -1) {
    return 0;
  } else {
    return last - first + 1;
  }
}

const arr = [1, 1, 2, 2, 2, 2, 3];
const x = 2;

const result = countOccurrences(arr, x);
console.log(result); // 4
// Этот код использует два бинарных поиска для нахождения первого и последнего вхождения элемента x в отсортированном массиве arr. Затем он вычисляет количество вхождений, как разницу между индексами первого и последнего вхождения, плюс 1. Функция countOccurrences возвращает это значение.